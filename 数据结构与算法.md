* [1.线性表](#1线性表)
    * [1.顺序表](#1顺序表)
    * [2.单链表](#2单链表)
    * [3.循环单链表](#3循环单链表)
    * [4.双链表](#4双链表)
    * [5.两个链表操作](#5两个链表操作)
* [2.子串匹配](#2子串匹配)
* [3.栈](#3栈)
* [4.队列](#4队列)
## 1.线性表
### 1.顺序表
顺序表就是一个数组，python中的list就是一个顺序表，一个顺序表存储在一整块内存区域中，因此根据下表查询顺序表的速度相当快，为O（1）。
关于list的实现，由于list可以随意插入，所以list的实现要采取一定的方法才可以，具体方法是这样：
* 当建立空list或很小的list时，先为其分配8个元素的存储空间。
* 若存满之后，就换一块4倍大的存储空间。
* 若表的大小超过50000，换存储空间时容量加倍。
### 2.单链表
__单链表操作__
* 首端插入
* 尾端插入
* 头端取出
* 尾端取出
```
# 自定义异常
class LinkedListUnderflow(ValueError):
    pass

# 单链表类
class LList(object):
    
    def __init__(self):
        self._head = None

    # 判断是否为空
    def is_empty(self):
        return self._head is None
    
    # 前端插入
    def prepend(self, elem):
        self._head = LNode(elem, self._head)
    
    # 取出头节点并删除
    def pop(self):
        if self._head is None:
            raise LinkedListUnderflow("in pop")
        e = self._head.elem
        self._head = self._head.next
        return e
    
    # 取出尾端
    def pop_last(self):
        if self._head is None:
            raise LinkedListUnderflow("in pop last")
        p = self._head
        while p.next.next is not None:
            p = p.next
        e = p.next.elem
        p.next = None
        return e

    # 后端插入
    def append(self, elem):
        if self._head  == None:
            self._head = LNode(elem)
            return
        p = self._head
        while p.next != None:
            p = p.next
        p.next = LNode(elem)

    def __str__(self):
        p = self._head
        s = ""
        while p is not None:
            s += " "+str(p.elem)
            p = p.next
        return s

# 节点类
class LNode:
    def __init__(self, elem, next=None):
        self.elem = elem
        self.next = next
```
### 3.循环单链表
循环单链表的尾端下一跳指向首端
__循环单链表操作__

```
# 自定义异常
class LCLinkedListUnderflow(ValueError):
    pass

# 节点类
class LNode:
    def __init__(self, elem, next=None):
        self.elem = elem
        self.next = next

# 单链表类
class LCList(object):
    
    def __init__(self):
        self._rear = None   #尾端

    # 判断是否为空
    def is_empty(self):
        return self._rear is None

    # 前端插入
    def prepend(self, elem):
        p = LNode(elem)
        if self._rear is None:  
            p.next = p
            self._rear = p
        else:
            p.next = self._rear.next
            self._rear.next = p
    
    # 前端弹出
    def pop(self):
        if self._rear is None:
            raise LCLinkedListUnderflow("in pop")
        p = self._rear.next #头
        if p == p.next:     #如果只有一个元素
            self._rear = None
            return p.elem
        else:
            p = self._rear.next
            self._rear.next = p.next
            return p.elem

    # 后端插入
    def append(self, elem):
        if self._rear is None:
            self._rear = LNode(elem)
            self._rear.next = self._rear
            return
        if self._rear is self._rear.next:
            p = LNode(elem)
            self._rear.next = p
            p.next = self._rear
            return 
        p = LNode(elem)
        p.next = self._rear.next
        self._rear.next = p
        self._rear = p
        

    def __str__(self):
        if self.is_empty():
            return "None"
        p = self._rear.next
        #s = ""
        s = str(p.elem)
        while p is not self._rear:
            p = p.next
            s += " "+str(p.elem)
        return s
```
### 4.双链表
### 5.两个链表操作

## 2.子串匹配
* KMP主要要解决两个问题
   * 1.求next值
   * 2.根据next值回溯
#### 什么是next值？
next值就是，在一个字符串中，某个子符前面的子串的最大公共前后缀的长度。比如：
* 对于字符串`abcac`来说：
第一个字符`a`对应的next值为-1，由于它前面没有字符，固定这样。
第二个字符`b`也是固定为0，因为它前面只有一个字符`a`，讨论前后缀没有意义。
第三个字符`c`就要开始判断了，它前面的子串`ab`存在前缀`a`和后缀`b`，显然这俩前后缀不一样，而且只存在这样一对前后缀，所以，第三个字符前面的子串的最大公共前后缀的长度为0。
第四个字符`a`的判断方法与第三个相同，结果也是0。
第五个字符`c`前面的子串`abca`存在前缀`a`和后缀`a`相同，所以她对应的next值为1。
所以最后的next值就为[-1,0,0,0,1]
#### next值有什么用？
知道了next值，我们就可以在子串匹配/查找时获得更快的速度。eg:
要从字符串`ababcabcacbab`中找到上面的字符串`abcac`，暴力的方法是从头到位一个一个比较：
```
ababcabcacbab
ab
 a
  abca
   a
    a
     abcac
```
这样做需要匹配6遍。

如果使用next值作为辅助，可以这样操作：
前面已经求出了`abcac`的next值为[-1,0,0,0,1]
```
ababcabcacbab
ab           #匹配到第三个字符失败，next值为0,往后跳一个
 a           #匹配到第二个字符失败，next值为0,往后跳一个
  abca       #匹配到第五个字符失败，next值为1,说明有相同前后缀，则前缀跳到后缀的地方
     abcac   #匹配成功
```
这样做需要匹配4遍。
这种方法叫做KMP（无回溯串匹配算法）。
#### 求next值的算法
递推计算最长相同前后缀长度：
```
P[0]...P[k-1],P[k]...P[i-k]...P[i-1],P[i],P[i+1]...</br>
                         
```
* 1.假设P[i-1]的计算结果为k-1，说明`P[0]~P[k-2] == P[k]~P[i-2]`。
* 2.比较P[i],P[k]</br>
    * 1.P[i]==P[k]，则P[i]的next值是P[i-1]+1，即k</br>
    * 2.P[i]!=P[k]，则退回到P[k]的next值，也就是考虑前面更短的保证匹配的前缀，因为P[0]...P[k-1]的前缀和P[i-k]...P[i-1]后缀相同</br>
* 3.如果k==-1，那么P[i]的next值就为0
```
def gen_next(p):
    k = -1
    i = 0
    m = len(p)
    pnext = [-1] * m    #初始化pnext都为-1
    while i < m-1:
        if k == -1 or p[i] == p[k]:    
            i += 1
            k += 1
            pnext[i] = k
        else:
            k = pnext[k]
    return pnext
```

### 3.栈
先进后出
```

```

### 4.队列
先进先出

python中有内置的queue数据结构，`import queue`即可，创建一个队列`q = queue.Queue(大小)`，以下是他的一些方法：
```
.empty()       #队列是否为空
.full()        #队列是否满
.put(elem)     #置入元素
.get()         #取出元素
.qsize()       #队列大小
```
