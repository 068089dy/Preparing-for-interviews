1.[线性表](#1.线性表)
    1.[顺序表](#1.顺序表)
    2.[]()
    3.[]()
    4.[]()
## 1.线性表
### 1.顺序表
### 2.单链表
__单链表操作__
* 首端插入
* 尾端插入
* 头端取出
* 尾端取出
```
# 自定义异常
class LinkedListUnderflow(ValueError):
    pass

# 单链表类
class LList(object):
    
    def __init__(self):
        self._head = None

    # 判断是否为空
    def is_empty(self):
        return self._head is None
    
    # 前端插入
    def prepend(self, elem):
        self._head = LNode(elem, self._head)
    
    # 取出头节点并删除
    def pop(self):
        if self._head is None:
            raise LinkedListUnderflow("in pop")
        e = self._head.elem
        self._head = self._head.next
        return e
    
    # 取出尾端
    def pop_last(self):
        if self._head is None:
            raise LinkedListUnderflow("in pop last")
        p = self._head
        while p.next.next is not None:
            p = p.next
        e = p.next.elem
        p.next = None
        return e

    # 后端插入
    def append(self, elem):
        if self._head  == None:
            self._head = LNode(elem)
            return
        p = self._head
        while p.next != None:
            p = p.next
        p.next = LNode(elem)

    def __str__(self):
        p = self._head
        s = ""
        while p is not None:
            s += " "+str(p.elem)
            p = p.next
        return s

# 节点类
class LNode:
    def __init__(self, elem, next=None):
        self.elem = elem
        self.next = next
```
### 3.循环单链表
循环单链表的尾端下一跳指向首端
__循环单链表操作__

```
# 自定义异常
class LCLinkedListUnderflow(ValueError):
    pass

# 节点类
class LNode:
    def __init__(self, elem, next=None):
        self.elem = elem
        self.next = next

# 单链表类
class LCList(object):
    
    def __init__(self):
        self._rear = None   #尾端

    # 判断是否为空
    def is_empty(self):
        return self._rear is None

    # 前端插入
    def prepend(self, elem):
        p = LNode(elem)
        if self._rear is None:  
            p.next = p
            self._rear = p
        else:
            p.next = self._rear.next
            self._rear.next = p
    
    # 前端弹出
    def pop(self):
        if self._rear is None:
            raise LCLinkedListUnderflow("in pop")
        p = self._rear.next #头
        if p == p.next:     #如果只有一个元素
            self._rear = None
            return p.elem
        else:
            p = self._rear.next
            self._rear.next = p.next
            return p.elem

    # 后端插入
    def append(self, elem):
        if self._rear is None:
            self._rear = LNode(elem)
            self._rear.next = self._rear
            return
        if self._rear is self._rear.next:
            p = LNode(elem)
            self._rear.next = p
            p.next = self._rear
            return 
        p = LNode(elem)
        p.next = self._rear.next
        self._rear.next = p
        self._rear = p
        

    def __str__(self):
        if self.is_empty():
            return "None"
        p = self._rear.next
        #s = ""
        s = str(p.elem)
        while p is not self._rear:
            p = p.next
            s += " "+str(p.elem)
        return s
```
### 4.双链表
### 5.两个链表操作

## 2.
